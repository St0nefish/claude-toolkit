#!/usr/bin/env bash
# catchup - Gather branch context for resuming work
# Exit codes: 0 success, 1 bad usage
#
# Token-optimized: sections with no content are omitted entirely.
# Files are listed but not read — Claude can Read what's relevant.

set -euo pipefail

usage() {
    cat <<'EOF'
Usage: catchup [--active-session] [directory]

Gathers branch context for resuming work. Sections with no
content are omitted. Files are listed, not read.

Options:
  --active-session  Include full content of the active session file
                    (truncated to last 150 lines if >200 lines)

If directory is omitted, uses the current working directory.
EOF
    exit 1
}

active_session=false
dir=""

for arg in "$@"; do
    case "$arg" in
        -h|--help) usage ;;
        --active-session) active_session=true ;;
        *)
            if [[ -z "$dir" ]]; then
                dir="$arg"
            else
                echo "Error: unexpected argument '$arg'" >&2
                usage
            fi
            ;;
    esac
done

dir="${dir:-.}"
cd "$dir"

# --- Check if this is a git repo ---
is_git=false
if git rev-parse --git-dir &>/dev/null; then
    is_git=true
fi

# --- Branch info ---
if $is_git; then
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

    base_branch=""
    if git rev-parse --verify main &>/dev/null; then
        base_branch="main"
    elif git rev-parse --verify master &>/dev/null; then
        base_branch="master"
    fi

    on_base=false
    if [[ -z "$base_branch" || "$current_branch" == "$base_branch" ]]; then
        on_base=true
    fi

    echo "=== BRANCH ==="
    echo "current: $current_branch"
    if ! $on_base; then
        echo "base: $base_branch"
        commit_count=$(git rev-list --count "$base_branch..HEAD" 2>/dev/null || echo "0")
        echo "ahead: $commit_count commits"
    fi
else
    echo "=== BRANCH ==="
    echo "(not a git repo)"
fi

# --- Branch commits (only on feature branches) ---
if $is_git && ! $on_base; then
    echo ""
    echo "=== BRANCH COMMITS ==="
    git log --oneline "$base_branch..HEAD" 2>/dev/null || true
fi

# --- Recent commits (only on base branch, for context) ---
if $is_git && $on_base; then
    echo ""
    echo "=== RECENT COMMITS ==="
    git log --oneline -10 2>/dev/null || true
fi

# --- Handoff detection (HEAD commit is a WIP handoff) ---
if $is_git; then
    head_subject=$(git log -1 --format=%s 2>/dev/null || true)
    if [[ "$head_subject" == WIP:* ]]; then
        echo ""
        echo "=== LATEST HANDOFF ==="
        git log -1 --format=%B 2>/dev/null || true
    fi
fi

# --- Changed files vs base (only on feature branches) ---
if $is_git && ! $on_base; then
    changed=$(git diff --name-only "$base_branch..HEAD" 2>/dev/null || true)
    if [[ -n "$changed" ]]; then
        echo ""
        echo "=== CHANGED FILES (vs $base_branch) ==="
        echo "$changed"
    fi
fi

# --- Uncommitted work (only if there is any) ---
if $is_git; then
    unstaged=$(git diff --name-only 2>/dev/null || true)
    staged=$(git diff --name-only --cached 2>/dev/null || true)
    untracked=$(git ls-files --others --exclude-standard 2>/dev/null || true)

    if [[ -n "$unstaged" || -n "$staged" || -n "$untracked" ]]; then
        echo ""
        echo "=== UNCOMMITTED ==="
        [[ -n "$staged" ]] && echo "staged:" && echo "$staged"
        [[ -n "$unstaged" ]] && echo "unstaged:" && echo "$unstaged"
        [[ -n "$untracked" ]] && echo "untracked:" && echo "$untracked"
    fi
fi

# --- TODO (always read if present) ---
if [[ -f .claude/todo.md ]]; then
    echo ""
    echo "=== TODO ==="
    cat .claude/todo.md
fi

# --- Plans (list only) ---
plans=()
if [[ -d .claude/plans ]]; then
    while IFS= read -r f; do
        plans+=("$f")
    done < <(ls -t .claude/plans/*.md 2>/dev/null || true)
fi
if [[ ${#plans[@]} -gt 0 ]]; then
    echo ""
    echo "=== PLANS ==="
    for f in "${plans[@]}"; do
        echo "$f"
    done
fi

# --- Sessions (list only) ---
sessions=()
if [[ -d .claude/sessions ]]; then
    while IFS= read -r f; do
        sessions+=("$f")
    done < <(ls -t .claude/sessions/*.md 2>/dev/null || true)
fi
active_session_file=""
if [[ ${#sessions[@]} -gt 0 ]]; then
    echo ""
    echo "=== SESSIONS ==="
    for f in "${sessions[@]}"; do
        if grep -q '\*\*Status:\*\* active' "$f" 2>/dev/null; then
            echo "$f  (active)"
            [[ -z "$active_session_file" ]] && active_session_file="$f"
        else
            echo "$f"
        fi
    done
fi

# --- Active session content (only with --active-session flag) ---
if $active_session && [[ -n "$active_session_file" ]]; then
    line_count=$(wc -l < "$active_session_file")
    echo ""
    echo "=== ACTIVE SESSION ==="
    echo "file: $active_session_file"
    if [[ "$line_count" -gt 200 ]]; then
        echo "(truncated — showing last 150 of $line_count lines)"
        tail -150 "$active_session_file"
    else
        cat "$active_session_file"
    fi
fi
