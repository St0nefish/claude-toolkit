#!/usr/bin/env bash
# catchup - Gather branch context for resuming work
# Exit codes: 0 success, 1 bad usage
#
# Token-optimized: sections with no content are omitted entirely.
# Files are listed but not read â€” Claude can Read what's relevant.

set -euo pipefail

usage() {
    cat <<'EOF'
Usage: catchup [directory]

Gathers branch context for resuming work. Sections with no
content are omitted. Files are listed, not read.

If directory is omitted, uses the current working directory.
EOF
    exit 1
}

case "${1:-}" in
    -h|--help) usage ;;
esac

dir="${1:-.}"
cd "$dir"

# --- Check if this is a git repo ---
is_git=false
if git rev-parse --git-dir &>/dev/null; then
    is_git=true
fi

# --- Branch info ---
if $is_git; then
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

    base_branch=""
    if git rev-parse --verify main &>/dev/null; then
        base_branch="main"
    elif git rev-parse --verify master &>/dev/null; then
        base_branch="master"
    fi

    on_base=false
    if [[ -z "$base_branch" || "$current_branch" == "$base_branch" ]]; then
        on_base=true
    fi

    echo "=== BRANCH ==="
    echo "current: $current_branch"
    if ! $on_base; then
        echo "base: $base_branch"
        commit_count=$(git rev-list --count "$base_branch..HEAD" 2>/dev/null || echo "0")
        echo "ahead: $commit_count commits"
    fi
else
    echo "=== BRANCH ==="
    echo "(not a git repo)"
fi

# --- Branch commits (only on feature branches) ---
if $is_git && ! $on_base; then
    echo ""
    echo "=== BRANCH COMMITS ==="
    git log --oneline "$base_branch..HEAD" 2>/dev/null || true
fi

# --- Recent commits (only on base branch, for context) ---
if $is_git && $on_base; then
    echo ""
    echo "=== RECENT COMMITS ==="
    git log --oneline -10 2>/dev/null || true
fi

# --- Changed files vs base (only on feature branches) ---
if $is_git && ! $on_base; then
    changed=$(git diff --name-only "$base_branch..HEAD" 2>/dev/null || true)
    if [[ -n "$changed" ]]; then
        echo ""
        echo "=== CHANGED FILES (vs $base_branch) ==="
        echo "$changed"
    fi
fi

# --- Uncommitted work (only if there is any) ---
if $is_git; then
    unstaged=$(git diff --name-only 2>/dev/null || true)
    staged=$(git diff --name-only --cached 2>/dev/null || true)
    untracked=$(git ls-files --others --exclude-standard 2>/dev/null || true)

    if [[ -n "$unstaged" || -n "$staged" || -n "$untracked" ]]; then
        echo ""
        echo "=== UNCOMMITTED ==="
        [[ -n "$staged" ]] && echo "staged:" && echo "$staged"
        [[ -n "$unstaged" ]] && echo "unstaged:" && echo "$unstaged"
        [[ -n "$untracked" ]] && echo "untracked:" && echo "$untracked"
    fi
fi

# --- TODO (always read if present) ---
if [[ -f .claude/todo.md ]]; then
    echo ""
    echo "=== TODO ==="
    cat .claude/todo.md
fi

# --- Plans (list only) ---
plans=()
if [[ -d .claude/plans ]]; then
    while IFS= read -r f; do
        plans+=("$f")
    done < <(ls -t .claude/plans/*.md 2>/dev/null || true)
fi
if [[ ${#plans[@]} -gt 0 ]]; then
    echo ""
    echo "=== PLANS ==="
    for f in "${plans[@]}"; do
        echo "$f"
    done
fi

# --- Sessions (list only) ---
sessions=()
if [[ -d .claude/sessions ]]; then
    while IFS= read -r f; do
        sessions+=("$f")
    done < <(ls -t .claude/sessions/*.md 2>/dev/null || true)
fi
if [[ ${#sessions[@]} -gt 0 ]]; then
    echo ""
    echo "=== SESSIONS ==="
    for f in "${sessions[@]}"; do
        if grep -q '\*\*Status:\*\* active' "$f" 2>/dev/null; then
            echo "$f  (active)"
        else
            echo "$f"
        fi
    done
fi
